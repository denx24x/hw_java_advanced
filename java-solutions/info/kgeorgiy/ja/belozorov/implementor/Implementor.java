package info.kgeorgiy.ja.belozorov.implementor;

import info.kgeorgiy.java.advanced.implementor.ImplerException;
import info.kgeorgiy.java.advanced.implementor.JarImpler;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.*;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;
import java.util.jar.Attributes;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;

/**
 * This class is used to generate {@code class} and {@code interface} implementations.
 *
 * @see #implement(Class, Path) generating .java code of class token
 * @see #implementJar(Class, Path) generating .jar implementation of class token
 * @see #main(String[]) command line usage
 */
public class Implementor implements JarImpler {

    /**
     * Generates predicate which filters values by uniqueness, applying {@link #getSignature(Method)}.
     *
     * @return required predicate
     */
    private Predicate<Method> distinctBySignature() {
        Set<String> seen = ConcurrentHashMap.newKeySet();
        return t -> seen.add(getSignature(t));
    }

    /**
     * Default constructor.
     */
    public Implementor() {
    }

    /**
     * Generates jar, which implement class provided in {@code args}.
     * Args should be provided in format: {@code -jar "classname" "output jar path"}.
     *
     * @param args command line arguments
     */
    public static void main(String[] args) {
        if (!(args.length == 3 && args[0].equals("-jar"))) {
            System.out.println("Wrong args: required -jar classname output_path");
            return;
        }
        try {
            new Implementor().implementJar(Class.forName(args[1]), Path.of(args[2]));
        } catch (ClassNotFoundException e) {
            System.out.println("Class not found!");
        } catch (ImplerException e) {
            System.out.println("Failed to implement class!");
        }
    }

    @Override
    public void implement(Class<?> token, Path root) throws ImplerException {
        if (token.isPrimitive() || Modifier.isPrivate(token.getModifiers()) || token == Enum.class
                || (!token.isInterface() && Arrays.stream(token.getDeclaredConstructors()).allMatch(v -> Modifier.isPrivate(v.getModifiers())))
                || Modifier.isFinal(token.getModifiers())) {
            throw new ImplerException("Can not implement");
        }
        Path target = root.resolve(getImplementedPath(token, ".java"));
        try {
            Files.createDirectories(target.getParent());
            Files.write(target, (Iterable<String>) generateImplementation(token)::iterator);
        } catch (IOException e) {
            System.out.println("Failed to write");
        }
    }

    /**
     * Generates implementation for provided {@code token} as java code.
     * Consists of header, generated by {@link #generateHeader(Class)}, and body, generated by {@link #generateBody(Class)}.
     *
     * @param token class token to generate implementation for
     * @return generated java code implementation as stream of lines
     */
    private Stream<String> generateImplementation(Class<?> token) {
        return Stream.concat(generateHeader(token), generateBody(token));
    }

    /**
     * Generates header of .java file for {@code token}.
     * Header consists of {@code package} and {@code class declaration}.
     * Package name is placed in first line if exists.
     * Class declaration is generated in format: {@code public class token_nameImpl implements/extends token_name}
     *
     * @param token class token to generate implementation for
     * @return implemented java code header as stream of lines
     */
    private Stream<String> generateHeader(Class<?> token) {
        String packageName = token.getPackageName().isEmpty() ? "" : ("package " + token.getPackageName() + ";");
        String className = String.format("public class %sImpl %s %s {", token.getSimpleName(), (token.isInterface() ? "implements" : "extends"), token.getCanonicalName());
        return Stream.of(packageName, "", className);
    }

    /**
     * Generates unique id string for {@code method}.
     * Created from method name and its params types.
     *
     * @param method method to generate id for
     * @return unique id for method
     */
    private String getSignature(Method method) {
        return method.getName() + Arrays.stream(method.getParameters()).map(v -> v.getType().getCanonicalName()).collect(Collectors.joining());
    }

    /**
     * Generates body of .java file for {@code token}.
     * Body consists of {@code implemented not private constructors}  and {@code implemented abstract methods}.
     * {@code Constructors} are generated by {@link #handleConstructor(Constructor)}.
     * {@code Methods} are generated by {@link #handleMethod(Method)}.
     *
     * @param token class token to generate implementation for
     * @return generated java code body for {@code token} as stream of lines
     */
    private Stream<String> generateBody(Class<?> token) {
        Stream<String> constructors = Arrays.stream(token.getDeclaredConstructors()).filter(v -> !Modifier.isPrivate(v.getModifiers())).map(this::handleConstructor);
        Stream<Method> methods = Arrays.stream(token.getMethods()).filter(v -> Modifier.isAbstract(v.getModifiers()));
        for (Class<?> current = token; current != null; current = current.getSuperclass()) {
            methods = Stream.concat(methods, Arrays.stream(current.getDeclaredMethods()).filter(v -> Modifier.isAbstract(v.getModifiers())));
        }
        return Stream.concat(Stream.concat(constructors, methods.filter(distinctBySignature()).map(this::handleMethod)), Stream.of("}"));
    }

    /**
     * Removes {@code Abstract} and {@code Transient} modifiers from {@code method}, so it can be implemented.
     *
     * @param method method to format
     * @return provided method modifiers, without {@code Abstract} and {@code Transient}
     */
    private String formatModifiers(Executable method) {
        return Modifier.toString(method.getModifiers() & ~Modifier.ABSTRACT & ~Modifier.TRANSIENT);
    }

    /**
     * Gets and formats {@code method} params, so it`s suitable for placing in {@code method} declaration.
     *
     * @param method method to get params from
     * @return {@code method} params in format {@code "type name"} joined with comma
     */
    private String getParams(Executable method) {
        return Arrays.stream(method.getParameters()).map(param -> String.format("%s %s", param.getType().getCanonicalName(), param.getName())).collect(Collectors.joining(","));
    }

    /**
     * Gets and formats exceptions, thrown by {@code method}, so it`s suitable for placing in {@code method} declaration.
     *
     * @param method method to get exceptions for
     * @return {@code method} exceptions joined with comma
     */
    private String getThrowing(Executable method) {
        return method.getExceptionTypes().length > 0 ? Arrays.stream(method.getExceptionTypes()).map(Class::getCanonicalName).collect(Collectors.joining(",", " throws ", " ")) : "";
    }

    /**
     * Generates implementation of {@code method}.
     * Implemented method returns default value for return type.
     *
     * @param method method to generate implementation for
     * @return {@code method} implementation as java code
     * @see #formatModifiers(Executable) generating modifiers
     * @see #getParams(Executable)} generating params
     * @see #getThrowing(Executable) generating thrown exceptions
     * @see #handleConstructor(Constructor) similar method for generating {@code Constructor} implementation
     */
    private String handleMethod(Method method) {
        String defaultValue = (method.getReturnType().isPrimitive() ? (method.getReturnType() == boolean.class ? "false" : "0") : "null");
        return String.format("%s %s %s(%s)%s{ return %s; }", formatModifiers(method), method.getReturnType().getCanonicalName(), method.getName(), getParams(method), getThrowing(method), method.getReturnType() == void.class ? "" : defaultValue);
    }

    /**
     * Generates implementation of {@code constructor}.
     * Implemented constructor only calls its {@code super(args)}.
     *
     * @param constructor constructor to generate implementation for
     * @return {@code constructor} implementation as java code
     * @see #formatModifiers(Executable) generating modifiers
     * @see #getParams(Executable)} generating params
     * @see #getThrowing(Executable) generating thrown exceptions
     * @see #handleMethod(Method) similar method for generating {@code Method} implementation
     */
    private String handleConstructor(Constructor<?> constructor) {
        String body = String.format("super(%s)", Arrays.stream(constructor.getParameters()).map(Parameter::getName).collect(Collectors.joining(",")));
        return String.format("%s %sImpl(%s)%s{%s;}", formatModifiers(constructor), constructor.getDeclaringClass().getSimpleName(), getParams(constructor), getThrowing(constructor), body);
    }

    /**
     * Returns path of {@code token} implementation file.
     *
     * @param token class token to get path for
     * @param ext   desired extension, expected to be {@code ".java"} or {@code ".class"}
     * @return desired path
     */
    private Path getImplementedPath(Class<?> token, String ext) {
        return Path.of(token.getPackageName().replace('.', File.separatorChar)).resolve(token.getSimpleName() + "Impl" + ext);
    }

    /**
     * Compiles {@code token} implementation generated by {@link #implement(Class, Path)} in .class file.
     * File is placed in {@code root} resolved by {@link #getImplementedPath(Class, String)} of {@code token}.
     *
     * @param root  root directory
     * @param token class token which implementation should be compiled
     * @throws ImplerException in case of {@code SecurityException} or compiling errors
     */
    public void compile(final Path root, Class<?> token) throws ImplerException {
        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        final Path file = root.resolve(getImplementedPath(token, ".java"));
        try {
            String classpath;
            try {
                classpath = Path.of(token.getProtectionDomain().getCodeSource().getLocation().toURI()).toString();
            } catch (NullPointerException | URISyntaxException e) {
                classpath = "";
            }
            final String[] args = {file.toString(), "-cp", classpath, "-encoding", "utf-8"};
            if (compiler.run(null, null, null, args) != 0) {
                throw new ImplerException("Error compiling java file");
            }
        } catch (SecurityException e) {
            throw new ImplerException("Error getting classpath", e);
        }
    }

    @Override
    public void implementJar(Class<?> token, Path jarFile) throws ImplerException {
        if (jarFile.getParent() == null) throw new ImplerException("Error creating temp dir");
        try {
            Path root = Files.createTempDirectory(jarFile.getParent(), "temp_");
            root.toFile().deleteOnExit();
            implement(token, root);
            compile(root, token);
            Manifest manifest = new Manifest();
            manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
            try (
                    JarOutputStream stream = new JarOutputStream(Files.newOutputStream(jarFile), manifest)
            ) {
                stream.putNextEntry(new ZipEntry(getImplementedPath(token, ".class").toString().replace(File.separatorChar, '/')));
                Files.copy(root.resolve(getImplementedPath(token, ".class")), stream);
            } catch (IOException e) {
                throw new ImplerException("Error while writing to jar", e);
            }
        } catch (IOException e) {
            throw new ImplerException("Error creating temp dir", e);
        }
    }
}
